(*  Title:       FreeCategory
    Author:      Eugene W. Stark <stark@cs.stonybrook.edu>, 2016
    Maintainer:  Eugene W. Stark <stark@cs.stonybrook.edu>
*)

chapter FreeCategory

theory FreeCategory
imports Category AbstractedCategory
begin

  text\<open>
    This theory defines locales for constructing the free category generated by
    a graph, as well as some special cases, including the discrete category generated
    by a set of objects, the ``quiver'' generated by a set of arrows, and a ``parallel pair''
    of arrows, which is the diagram shape required for equalizers.
    Other diagram shapes can be constructed in a similar fashion.
    The development looks more complicated that it really is, for two reasons:
    first, for each particular construction once the desired category is obtained it is
    necessary to establish facts that completely characterize its structure and allow it to be
    used in applications; and second, for each construction we define an opaque arrow type
    to ensure that client theories depend only on the explicit characterizing facts and
    not on any properties implicit in the particular construction.
\<close>

  section Graphs

  text\<open>
    The following locale gives a definition of graphs in a traditional style.
\<close>

  locale graph =
  fixes Obj :: "'obj set"
  and Arr :: "'arr set"
  and Dom :: "'arr \<Rightarrow> 'obj"
  and Cod :: "'arr \<Rightarrow> 'obj"
  assumes dom_is_obj: "x \<in> Arr \<Longrightarrow> Dom x \<in> Obj"
  and cod_is_obj: "x \<in> Arr \<Longrightarrow> Cod x \<in> Obj"
  begin

    text\<open>
      The list of arrows @{term p} forms a path from object @{term x} to object @{term y}
      if the domains and codomains of the arrows match up in the expected way.
\<close>

    definition path
    where "path x y p \<equiv> (p = [] \<and> x = y \<and> x \<in> Obj) \<or>
                        (p \<noteq> [] \<and> x = Dom (hd p) \<and> y = Cod (last p) \<and>
                        (\<forall>n. n \<ge> 0 \<and> n < length p \<longrightarrow> nth p n \<in> Arr) \<and>
                        (\<forall>n. n \<ge> 0 \<and> n < (length p)-1 \<longrightarrow> Cod (nth p n) = Dom (nth p (n+1))))"

    lemma path_Obj:
    assumes "x \<in> Obj"
    shows "path x x []"
      using assms path_def by simp

    lemma path_single_Arr:
    assumes "x \<in> Arr"
    shows "path (Dom x) (Cod x) [x]"
      using assms path_def by simp

    lemma path_concat:
    assumes "path x y p" and "path y z q"
    shows "path x z (p @ q)"
    proof -
      have "p = [] \<or> q = [] \<Longrightarrow> ?thesis"
        using assms path_def by auto
      moreover have "p \<noteq> [] \<and> q \<noteq> [] \<Longrightarrow> ?thesis"
      proof -
        assume pq: "p \<noteq> [] \<and> q \<noteq> []"
        have Cod_last: "Cod (last p) = Cod (nth (p @ q) ((length p)-1))"
          using assms pq by (simp add: last_conv_nth nth_append)
        moreover have Dom_hd: "Dom (hd q) = Dom (nth (p @ q) (length p))"
          using assms pq by (simp add: hd_conv_nth less_not_refl2 nth_append)
        show ?thesis
        proof -
          have 1: "\<And>n. n \<ge> 0 \<and> n < length (p @ q) \<Longrightarrow> nth (p @ q) n \<in> Arr"
          proof -
            fix n
            assume n: "n \<ge> 0 \<and> n < length (p @ q)"
            have "(n \<ge> 0 \<and> n < length p) \<or> (n \<ge> length p \<and> n < length (p @ q))"
              using n by auto
            thus "nth (p @ q) n \<in> Arr"
              using assms pq nth_append path_def le_add_diff_inverse length_append
                    less_eq_nat.simps(1) nat_add_left_cancel_less
              by metis
          qed
          have 2: "\<And>n. n \<ge> 0 \<and> n < length (p @ q) - 1 \<Longrightarrow>
                                    Cod (nth (p @ q) n) = Dom (nth (p @ q) (n+1))"
          proof -
            fix n
            assume n: "n \<ge> 0 \<and> n < length (p @ q) - 1"
            have 1: "(n \<ge> 0 \<and> n < (length p) - 1) \<or> (n \<ge> length p \<and> n < length (p @ q) - 1)
                       \<or> n = (length p) - 1"
              using n by auto
            thus "Cod (nth (p @ q) n) = Dom (nth (p @ q) (n+1))"
            proof -
              have "n \<ge> 0 \<and> n < (length p) - 1 \<Longrightarrow> ?thesis"
                using assms pq nth_append path_def by (metis add_lessD1 less_diff_conv)
              moreover have "n = (length p) - 1 \<Longrightarrow> ?thesis"
                using assms pq nth_append path_def Dom_hd Cod_last by simp
              moreover have "n \<ge> length p \<and> n < length (p @ q) - 1 \<Longrightarrow> ?thesis"
              proof -
                assume 1: "n \<ge> length p \<and> n < length (p @ q) - 1"
                have "Cod (nth (p @ q) n) = Cod (nth q (n - length p))"
                  using 1 nth_append leD by metis
                also have "... = Dom (nth q (n - length p + 1))"
                  using 1 assms(2) path_def by auto
                also have "... = Dom (nth (p @ q) (n + 1))"
                  using 1 nth_append
                  by (metis Nat.add_diff_assoc2 ex_least_nat_le le_0_eq le_add1 le_neq_implies_less
                            le_refl le_trans length_0_conv pq)
                finally show "Cod (nth (p @ q) n) = Dom (nth (p @ q) (n + 1))" by auto
              qed
              ultimately show ?thesis using 1 by auto
            qed
          qed
          show ?thesis
            unfolding path_def using assms pq path_def hd_append2 Cod_last Dom_hd 1 2
            by simp
        qed
      qed
      ultimately show ?thesis by auto
    qed

  end

  section "Free Categories"

  text\<open>
    The free category generated by a graph has as its arrows all triples @{term "(x, y, p)"},
    where @{term x} and @{term y} are objects and @{term p} is a path from @{term x} to @{term y}.
    We use an option type to provide a value to be used for @{term null}.
\<close>

  locale free_category =
    G: graph Obj Arr D C
  for Obj :: "'obj set"
  and Arr :: "'arr set"
  and D :: "'arr \<Rightarrow> 'obj"
  and C :: "'arr \<Rightarrow> 'obj"
  begin

    typedef ('o, 'a) arr = "UNIV :: ('o * 'o * 'a list) option set" ..

    definition Null
    where "Null = Abs_arr None"

    definition Dom
    where "Dom f = fst (the (Rep_arr f))"

    definition Cod
    where "Cod f = fst (snd (the (Rep_arr f)))"

    definition Path
    where "Path f = snd (snd (the (Rep_arr f)))"

    definition mkArr
    where "mkArr x y p \<equiv> if G.path x y p then Abs_arr (Some (x, y, p)) else Null"

    abbreviation isArr
    where "isArr f \<equiv> f \<noteq> Null \<and> G.path (Dom f) (Cod f) (Path f)"

    lemma mkArr_not_Null:
    shows "mkArr x y p \<noteq> Null \<longleftrightarrow> G.path x y p"
      using mkArr_def
      by (metis Abs_arr_inverse Null_def UNIV_I option.distinct(1))

    lemma Dom_mkArr [simp]:
    assumes "mkArr x y p \<noteq> Null"
    shows "Dom (mkArr x y p) = x"
      using assms mkArr_def Dom_def
      by (metis Abs_arr_inverse UNIV_I fst_conv option.sel)

    lemma Cod_mkArr [simp]:
    assumes "mkArr x y p \<noteq> Null"
    shows "Cod (mkArr x y p) = y"
      using assms mkArr_def Cod_def
      by (metis Abs_arr_inverse UNIV_I fst_conv snd_conv option.sel)

    lemma Path_mkArr [simp]:
    assumes "mkArr x y p \<noteq> Null"
    shows "Path (mkArr x y p) = p"
      using assms mkArr_def Path_def
      by (metis Abs_arr_inverse UNIV_I snd_conv option.sel)

    lemma mkArr_Path [simp]:
    assumes "isArr f"
    shows "mkArr (Dom f) (Cod f) (Path f) = f"
      by (metis Cod_def Dom_def Null_def Path_def Rep_arr_inverse assms mkArr_def
                option.exhaust_sel surjective_pairing)

    lemma Dom_in_Obj:
    assumes "isArr f"
    shows "Dom f \<in> Obj"
      using assms G.path_def G.dom_is_obj hd_conv_nth leI length_greater_0_conv
            less_numeral_extra(3)
      by fastforce

    lemma Cod_in_Obj:
    assumes "isArr f"
    shows "Cod f \<in> Obj"
      using assms G.path_def G.cod_is_obj
      by (metis diff_less last_conv_nth leI length_greater_0_conv less_imp_le_nat neq0_conv
                not_one_le_zero)

    text\<open>
      Composition is concatenation of paths.
\<close>

    definition comp     (infixr "\<cdot>" 55)
    where "g \<cdot> f \<equiv> if isArr g \<and> isArr f \<and> Dom g = Cod f
                   then mkArr (Dom f) (Cod g) (Path f @ Path g)
                   else Null"

    interpretation partial_magma comp
      using comp_def by (unfold_locales, metis)

    notation in_hom     ("\<guillemotleft>_ : _ \<rightarrow> _\<guillemotright>")

    lemma null_char:
    shows "null = Null"
      by (metis comp_null(1) comp_def)

    lemma in_Obj_implies_ide:
    assumes "x \<in> Obj"
    shows "ide (mkArr x x [])"
      unfolding ide_def
      using assms comp_def null_char Cod_mkArr Dom_mkArr Path_mkArr append_Nil append_Nil2
            mkArr_Path G.path_Obj mkArr_not_Null
      by fastforce

    lemma has_domain_char:
    shows "domains f \<noteq> {} \<longleftrightarrow> isArr f"
    proof
      show "domains f \<noteq> {} \<Longrightarrow> isArr f"
        unfolding domains_def
        using Collect_empty_eq comp_def null_char by fastforce
      show "isArr f \<Longrightarrow> domains f \<noteq> {}"
      proof (unfold domains_def)
        assume 1: "f \<noteq> Null \<and> G.path (Dom f) (Cod f) (Path f)"
        hence 2: "Dom f \<in> Obj"
          using Dom_in_Obj by force
        hence "comp f (mkArr (Dom f) (Dom f) []) \<noteq> null"
          using 1 by (simp add: G.path_Obj comp_def mkArr_not_Null null_char)
        thus "{a. ide a \<and> comp f a \<noteq> null} \<noteq> {}"
          using 2 in_Obj_implies_ide by auto
      qed
    qed

    lemma has_codomain_char:
    shows "codomains f \<noteq> {} \<longleftrightarrow> isArr f"
    proof
      show "codomains f \<noteq> {} \<Longrightarrow> isArr f"
        unfolding codomains_def
        using Collect_empty_eq comp_def null_char by fastforce
      show "isArr f \<Longrightarrow> codomains f \<noteq> {}"
      proof (unfold codomains_def)
        assume 1: "f \<noteq> Null \<and> G.path (Dom f) (Cod f) (Path f)"
        hence 2: "Cod f \<in> Obj"
          using Cod_in_Obj by force
        hence "comp (mkArr (Cod f) (Cod f) []) f \<noteq> null"
          using 1 G.path_Obj comp_def mkArr_not_Null null_char by auto
        thus "{b. ide b \<and> comp b f \<noteq> null} \<noteq> {}"
          using 2 in_Obj_implies_ide by auto
      qed
    qed

    interpretation category comp
    proof
      fix f g h
      show "g \<cdot> f \<noteq> null \<Longrightarrow> seq g f"
        using comp_def arr_def G.path_concat Path_mkArr has_codomain_char null_char
        by auto
      show "(domains f \<noteq> {}) = (codomains f \<noteq> {})"
        by (simp add: has_domain_char has_codomain_char)
      assume gf: "seq g f" and hgf: "seq h (g \<cdot> f)"
      have isArr: "isArr h \<and> isArr g"
        using gf hgf by (metis comp_def not_arr_null null_char)
      then have "Dom h = Cod g"
        using gf hgf Cod_mkArr [of "Dom g" "Cod g" "Path g"]
        by (metis Cod_mkArr comp_null(2) comp_def not_arr_null)
      with isArr show "seq h g"
        using comp_def null_char mkArr_not_Null G.path_concat
        using arr_def has_domain_char by auto
      next
      fix f g h
      assume hg: "seq h g" and hgf: "seq (h \<cdot> g) f"
      have isArr: "isArr g \<and> isArr f"
        using hg hgf by (metis comp_def not_arr_null null_char)
      then have "Dom g = Cod f"
        using hg hgf Dom_mkArr [of "Dom g" "Cod g" "Path g"]
        by (metis Dom_mkArr comp_null(2) comp_def not_arr_null)
      with isArr show "seq g f"
        using comp_def null_char mkArr_not_Null G.path_concat
        using arr_def has_domain_char by auto
      next
      fix f g h
      assume gf: "seq g f" and hg: "seq h g"
      have 1: "isArr h \<and> isArr g \<and> isArr f \<and> Dom h = Cod g \<and> Dom g = Cod f"
        using gf hg comp_def null_char by (metis not_arr_null)
      show "seq (h \<cdot> g) f"
        using 1 comp_def null_char Dom_mkArr Cod_mkArr Path_mkArr mkArr_not_Null G.path_concat
              arr_def has_codomain_char
        by fastforce
      show "(h \<cdot> g) \<cdot> f = h \<cdot> g \<cdot> f"
        using 1 comp_def null_char Dom_mkArr Cod_mkArr Path_mkArr mkArr_not_Null G.path_concat
              append_assoc
        by force
    qed

    lemma is_category:
    shows "category comp" ..

  end

  sublocale free_category \<subseteq> category comp
    using is_category by auto

  context free_category
  begin

    lemma arr_char:
    shows "arr f \<longleftrightarrow> isArr f"
      using has_codomain_char has_codomain_iff_arr by auto

    lemma dom_char:
    shows "dom f = (if arr f then mkArr (Dom f) (Dom f) [] else null)"
    proof -
      have "\<not>arr f \<Longrightarrow> dom f = null"
        by (simp add: has_domain_iff_arr dom_def)
      moreover have "arr f \<Longrightarrow> dom f = mkArr (Dom f) (Dom f) []"
        apply (intro dom_eqI)
        using Dom_in_Obj arr_char in_Obj_implies_ide
         apply auto[1]
        by (simp add: Dom_in_Obj G.path_Obj arr_char mkArr_not_Null comp_def)
      ultimately show ?thesis by auto
    qed

    lemma cod_char:
    shows "cod f = (if arr f then mkArr (Cod f) (Cod f) [] else null)"
    proof -
      have "\<not>arr f \<Longrightarrow> cod f = null"
        by (simp add: has_codomain_iff_arr cod_def)
      moreover have "arr f \<Longrightarrow> cod f = mkArr (Cod f) (Cod f) []"
        apply (intro cod_eqI)
        using Cod_in_Obj arr_char in_Obj_implies_ide
         apply auto[1]
        by (simp add: Cod_in_Obj G.path_Obj arr_char mkArr_not_Null comp_def)
      ultimately show ?thesis by auto
    qed

    lemma ide_char:
    shows "ide f \<longleftrightarrow> f \<in> (\<lambda>x. mkArr x x []) ` Obj"
    proof
      show "ide f \<Longrightarrow> f \<in> (\<lambda>x. mkArr x x []) ` Obj"
        by (metis (no_types, lifting) Dom_in_Obj ide_in_hom arr_char dom_char in_homE image_iff)
      show "f \<in> (\<lambda>x. mkArr x x []) ` Obj \<Longrightarrow> ide f"
        using in_Obj_implies_ide by auto
    qed

    lemma arr_empty [simp]:
    assumes "x \<in> Obj"
    shows "arr (mkArr x x [])"
      using assms by (simp add: G.path_Obj arr_char mkArr_not_Null)

    lemma arr_single [simp]:
    assumes "x \<in> Arr"
    shows "arr (mkArr (D x) (C x) [x])"
      using assms by (simp add: G.path_single_Arr arr_char mkArr_not_Null)

    lemma dom_mkArr [simp]:
    assumes "arr (mkArr x y p)"
    shows "dom (mkArr x y p) = mkArr x x []"
      using assms dom_char arr_char by auto

    lemma cod_mkArr [simp]:
    assumes "arr (mkArr x y p)"
    shows "cod (mkArr x y p) = mkArr y y []"
      using assms cod_char arr_char by auto

    lemma comp_mkArr [simp]:
    assumes "seq (mkArr y z q) (mkArr x y p)"
    shows "comp (mkArr y z q) (mkArr x y p) = mkArr x z (p @ q)"
      using assms arr_char comp_def by auto

    lemma mkArr_eqI:
    assumes "arr (mkArr a b p)"
    shows "mkArr a b p = mkArr a b p' \<longleftrightarrow> p = p'"
      using assms arr_char Path_mkArr by metis

  end

  section "Discrete Categories"

  text\<open>
    A discrete category is a free category generated by a graph with no arrows.
\<close>

  locale discrete_category =
    FC: free_category Obj "{} :: unit set" "\<lambda>_. undefined" "\<lambda>_. undefined"
  for Obj :: "'obj set"
  begin

    lemma FC_arr_char:
    shows "FC.arr f \<longleftrightarrow> f \<in> (\<lambda>x. FC.mkArr x x []) ` Obj"
    proof
      show "FC.arr f \<Longrightarrow> f \<in> (\<lambda>x. FC.mkArr x x []) ` Obj"
        using FC.arr_char FC.ide_char FC.mkArr_Path FC.G.path_def length_greater_0_conv
        by (metis (no_types, lifting) FC.cod_char FC.ide_cod empty_iff le_eq_less_or_eq)
      show "f \<in> (\<lambda>x. FC.mkArr x x []) ` Obj \<Longrightarrow> FC.arr f"
        using FC.ide_char by auto
    qed

    lemma FC_in_hom_char:
    shows "FC.in_hom f a b \<longleftrightarrow> FC.arr f \<and> f = a \<and> f = b"
      using FC.ide_char FC_arr_char by auto

    typedef 'a arr = "UNIV :: ('a, unit) free_category.arr set" ..

    interpretation AC: abstracted_category FC.comp Abs_arr Rep_arr UNIV
      using Rep_arr_inverse Abs_arr_inverse by (unfold_locales, auto)

    definition comp     (infixr "\<cdot>" 55)
    where "comp \<equiv> AC.comp"

    lemma is_category:
    shows "category comp"
      using AC.category_axioms comp_def by auto

    interpretation category comp
      using is_category by auto

    notation in_hom     ("\<guillemotleft>_ : _ \<rightarrow> _\<guillemotright>")

    definition mkIde
    where "mkIde x \<equiv> if x \<in> Obj then Abs_arr (FC.mkArr x x []) else null"

    definition toObj
    where "toObj f \<equiv> FC.Dom (Rep_arr f)"

    lemma arr_char:
    shows "arr f \<longleftrightarrow> f \<in> mkIde ` Obj"
    proof
      show "arr f \<Longrightarrow> f \<in> mkIde ` Obj"
      proof -
        assume f: "arr f"
        obtain A where A: "A \<in> Obj \<and> Rep_arr f = FC.mkArr A A []"
          using f AC.arr_char FC_arr_char FC.ide_char FC_in_hom_char FC.Dom_in_Obj
                FC.arr_char FC.dom_char comp_def
          by auto
        then have "f = mkIde A"
          by (metis Rep_arr_inverse mkIde_def)
        with A show ?thesis by auto
      qed
      show "f \<in> mkIde ` Obj \<Longrightarrow> arr f"
        using FC_arr_char mkIde_def AC.arr_char AC.domain_closed AC.rep_abs FC.arr_empty
              f_inv_into_f inv_into_into comp_def
        by auto
    qed

    lemma dom_char:
    shows "dom f = (if arr f then f else null)"
      using AC.dom_char arr_char comp_def AC.arr_char FC.ide_char FC_arr_char
      by (simp add: Rep_arr_inverse)

    lemma cod_char:
    shows "cod f = (if arr f then f else null)"
      using AC.cod_char comp_def Rep_arr_inverse cod_dom dom_char
      by auto

    lemma dom_simp [simp]:
    assumes "arr f"
    shows "dom f = f"
      using assms dom_char by simp

    lemma cod_simp [simp]:
    assumes "arr f"
    shows "cod f = f"
      using assms cod_char by simp

    lemma in_hom_char:
    shows "\<guillemotleft>f : a \<rightarrow> b\<guillemotright> \<longleftrightarrow> arr f \<and> f = a \<and> f = b"
      by auto

    lemma comp_char:
    shows "g \<cdot> f = (if seq g f then f else null)"
      using AC.comp_char comp_def comp_cod_arr in_hom_char dom_char
      by (metis (no_types, lifting) seqE)

    lemma comp_simp [simp]:
    assumes "seq g f"
    shows "g \<cdot> f = f"
      using assms comp_char by meson

    lemma is_discrete:
    shows "ide f \<longleftrightarrow> arr f"
      using arr_char dom_char in_hom_char ide_in_hom by metis

    lemma ide_mkIde:
    assumes "x \<in> Obj"
    shows "ide (mkIde x)"
      using assms mkIde_def arr_char image_iff is_discrete by auto

    lemma toObj_in_Obj:
    assumes "arr a"
    shows "toObj a \<in> Obj"
      using assms toObj_def
      by (metis AC.arr_char FC.Dom_in_Obj FC.arr_char comp_def)

    lemma toObj_mkIde [simp]:
    assumes "x \<in> Obj"
    shows "toObj (mkIde x) = x"
      using assms toObj_def mkIde_def Abs_arr_inverse
      by (metis FC.Dom_mkArr FC.arr_empty FC.not_arr_null FC.null_char UNIV_I)

    lemma mkIde_toObj [simp]:
    assumes "arr a"
    shows "mkIde (toObj a) = a"
      using assms mkIde_def
      by (metis (no_types, lifting) arr_char imageE toObj_mkIde)

  end

  sublocale discrete_category \<subseteq> category comp
    using is_category by auto

  text\<open>
    The empty category is the discrete category generated by an empty set of objects.
\<close>

  locale empty_category =
    discrete_category "{} :: unit set"
  begin

    lemma is_empty:
    shows "\<not>arr f"
      using arr_char by simp

  end

  section "Quivers"

  text\<open>
    A quiver is a two-object category whose non-identity arrows all point in the
    same direction.  A quiver is specified by giving the set of these non-identity arrows.
\<close>

  locale quiver =
    FC: free_category "{False, True}" Arr "\<lambda>_. False" "\<lambda>_. True"
  for Arr :: "'arr set"
  begin

    lemma FC_ide_char:
    shows "FC.ide f \<longleftrightarrow> f = FC.mkArr False False [] \<or> f = FC.mkArr True True []"
      by (simp add: FC.ide_char)

    lemma FC_arr_char:
    shows "FC.arr f \<longleftrightarrow> f = FC.mkArr False False [] \<or> f = FC.mkArr True True [] \<or>
                        f \<in> (\<lambda>x. FC.mkArr False True [x]) ` Arr"
    proof
      assume f: "f = FC.mkArr False False [] \<or> f = FC.mkArr True True [] \<or>
                 f \<in> (\<lambda>x. FC.mkArr False True [x]) ` Arr"
      show "FC.arr f" using f by auto
      next
      assume f: "FC.arr f"
      have "\<not>(f = FC.mkArr False False [] \<or> f = FC.mkArr True True [])
                     \<Longrightarrow> f \<in> (\<lambda>x. FC.mkArr False True [x]) ` Arr"
      proof -
        assume f': "\<not>(f = FC.mkArr False False [] \<or> f = FC.mkArr True True [])"
        have 0: "FC.Dom f = False \<and> FC.Cod f = True"
        proof -
          have "f \<noteq> FC.Null \<and> FC.G.path (FC.Dom f) (FC.Cod f) (FC.Path f)"
            using FC.arr_char f by blast
          then show ?thesis
            by (metis (full_types) FC.G.path_def FC.mkArr_Path f')
        qed
        hence 1: "f = FC.mkArr False True (FC.Path f)"
        proof -
          have "FC.mkArr (FC.Dom f) (FC.Cod f) (FC.Path f) = f"
            using FC.arr_char FC.mkArr_Path f by meson
          then show ?thesis
            by (simp add: 0)
        qed
        moreover have "length (FC.Path f) = 1"
        proof -
          have 2: "length (FC.Path f) \<noteq> 0"
            using f f' FC_ide_char FC.arr_char FC.mkArr_Path FC.G.path_def length_0_conv
            by (metis (full_types))
          moreover have "\<And>x y p. length p > 1 \<Longrightarrow> \<not>FC.G.path x y p"
            using FC.G.path_def less_diff_conv by auto
          thus ?thesis by (metis FC.arr_char 2 f less_one linorder_neqE_nat)
        qed
        moreover have "\<And>p. length p = 1 \<longleftrightarrow> (\<exists>x. p = [x])"
          by(auto simp: length_Suc_conv)
        ultimately have "\<exists>x. x \<in> Arr \<and> FC.Path f = [x]"
          by (metis FC.G.path_def FC.arr_char f FC.mkArr_def less_or_eq_imp_le nth_Cons_0
                    zero_less_one)
        thus "f \<in> (\<lambda>x. FC.mkArr False True [x]) ` Arr"
          using 1 by auto
      qed
      thus "f = FC.mkArr False False [] \<or> f = FC.mkArr True True [] \<or>
            f \<in> (\<lambda>x. FC.mkArr False True [x]) ` Arr"
        by auto
    qed

    lemma FC_seq_char:
    shows "FC.seq g f \<longleftrightarrow> FC.arr g \<and> FC.arr f \<and>
                          ((f = FC.mkArr False False [] \<and> g \<noteq> FC.mkArr True True []) \<or>
                           (f \<noteq> FC.mkArr False False [] \<and> g = FC.mkArr True True []))"
    proof
      assume gf: "FC.arr g \<and> FC.arr f \<and>
                  ((f = FC.mkArr False False [] \<and> g \<noteq> FC.mkArr True True []) \<or>
                   (f \<noteq> FC.mkArr False False [] \<and> g = FC.mkArr True True []))"
      show "FC.seq g f"
        using gf FC_arr_char FC_ide_char by (intro FC.seqI; fastforce)
      next
      assume gf: "FC.seq g f"
      hence 1: "FC.arr f \<and> FC.arr g \<and> FC.dom g = FC.cod f" by auto
      have "FC.Cod f = False \<Longrightarrow> f = FC.mkArr False False []"
      proof -
        assume "FC.Cod f = False"
        moreover have "FC.mkArr (FC.Dom f) (FC.Cod f) (FC.Path f) = f"
          using gf FC.arr_char [of f] by auto
        ultimately show ?thesis
          using FC.G.path_def FC.arr_char [of f] gf by auto
      qed
      moreover have "FC.Cod f = True \<Longrightarrow> g = FC.mkArr True True []"
      proof -
        assume f: "FC.Cod f = True"
        have "FC.Null \<noteq> g"
          using FC.arr_char gf by blast
        moreover have "FC.Cod f = FC.Dom g"
        proof -
          have "\<not> FC.Dom (FC.mkArr False False [])"
            using FC.not_arr_null FC.null_char FC_arr_char by force
          moreover have "FC.Dom (FC.mkArr True True [])"
            using FC.not_arr_null FC.null_char FC_arr_char by auto
          ultimately show ?thesis
            by (metis FC.arr_char FC.comp_def gf)
        qed
        ultimately show ?thesis
          using f FC_arr_char [of g] gf by auto
      qed
      ultimately have "f = FC.mkArr False False [] \<or> g = FC.mkArr True True []"
        using gf FC_arr_char by auto
      moreover have "\<not>(f = FC.mkArr False False [] \<and> g = FC.mkArr True True [])"
        using 1 by (metis FC.arr_char FC.dom_mkArr FC.Dom_mkArr FC.cod_mkArr)
      ultimately show "FC.arr g \<and> FC.arr f \<and>
                       ((f = FC.mkArr False False [] \<and> g \<noteq> FC.mkArr True True []) \<or>
                        (f \<noteq> FC.mkArr False False [] \<and> g = FC.mkArr True True []))"
        using 1 by metis
    qed

    typedef 'a arr = "UNIV :: (bool, 'a) free_category.arr set" ..

    interpretation AC: abstracted_category FC.comp Abs_arr Rep_arr UNIV
      using Rep_arr_inverse Abs_arr_inverse by (unfold_locales, auto)

    definition comp     (infixr "\<cdot>" 55)
    where "comp \<equiv> AC.comp"

    lemma is_category:
    shows "category comp"
    proof -
      have "category AC.comp" ..
      thus "category comp" using comp_def by auto
    qed

    interpretation category comp
      using is_category by auto

    notation in_hom ("\<guillemotleft>_ : _ \<rightarrow> _\<guillemotright>")

    definition Zero
    where "Zero \<equiv> Abs_arr (FC.mkArr False False [])"

    definition One
    where "One \<equiv> Abs_arr (FC.mkArr True True [])"

    definition mkArr
    where "mkArr x \<equiv> if x \<in> Arr then Abs_arr (FC.mkArr False True [x]) else null"

    definition toArr
    where "toArr f \<equiv> hd (FC.Path (Rep_arr f))"

    lemma ide_char:
    shows "ide f \<longleftrightarrow> f = Zero \<or> f = One"
      using comp_def Zero_def One_def
      by (metis AC.ide_char Abs_arr_inverse FC_ide_char Rep_arr_inject UNIV_I)

    lemma not_ide_mkArr:
    shows "\<not>ide (mkArr x)"
      using mkArr_def ide_char ide_def Zero_def One_def
      by (metis Abs_arr_inverse FC.G.path_single_Arr UNIV_I FC.Cod_mkArr FC.Dom_mkArr
                FC.mkArr_not_Null)

    lemma arr_char:
    shows "arr f \<longleftrightarrow> f = Zero \<or> f = One \<or> f \<in> mkArr ` Arr"
    proof -
      obtain G :: "'arr set \<Rightarrow> ('arr \<Rightarrow> (bool, 'arr) FC.arr) \<Rightarrow> (bool, 'arr) FC.arr \<Rightarrow> 'arr"
        where "\<forall>A F h. (\<exists>h'. h' \<in> A \<and> h = F h') \<longleftrightarrow> (G A F h \<in> A \<and> h = F (G A F h))"
        by moura
      hence 1: "\<forall>a f A. (a \<in> f ` A \<longrightarrow> G A f a \<in> A \<and> a = f (G A f a)) \<and>
                        (a \<notin> f ` A \<longrightarrow> (\<forall>a'. a' \<in> A \<longrightarrow> a \<noteq> f a'))"
        by auto
      have 2: "Rep_arr f = FC.mkArr False False [] \<longrightarrow> f = Zero"
        by (metis (no_types) Rep_arr_inverse Zero_def)
      have 3: "Rep_arr f = FC.mkArr True True [] \<longrightarrow> f = One"
        by (metis One_def Rep_arr_inverse)
      have "(Rep_arr f \<in> (\<lambda>a. FC.mkArr False True [a]) ` Arr \<longrightarrow>
               G Arr (\<lambda>a. FC.mkArr False True [a]) (Rep_arr f) \<in> Arr \<and>
               Rep_arr f =
               FC.mkArr False True [G Arr (\<lambda>a. FC.mkArr False True [a]) (Rep_arr f)])
            \<and> (Rep_arr f \<notin> (\<lambda>a. FC.mkArr False True [a]) ` Arr \<longrightarrow>
                 (\<forall>a. a \<notin> Arr \<or> Rep_arr f \<noteq> FC.mkArr False True [a]))"
        using 1 by meson
      moreover have
          "f \<noteq> mkArr (G Arr (\<lambda>a. FC.mkArr False True [a]) (Rep_arr f))
             \<Longrightarrow> G Arr (\<lambda>a. FC.mkArr False True [a]) (Rep_arr f) \<notin> Arr \<or>
                 Rep_arr f \<noteq>
                 FC.mkArr False True [G Arr (\<lambda>a. FC.mkArr False True [a]) (Rep_arr f)]"
        by (metis Rep_arr_inverse mkArr_def)
      ultimately have "arr f \<Longrightarrow> f = Zero \<or> f = One \<or> f \<in> mkArr ` Arr"
        using 2 3 AC.arr_char FC_arr_char comp_def by force
      thus "arr f \<longleftrightarrow> (f = Zero \<or> f = One \<or> f \<in> mkArr ` Arr)"
        using AC.arr_char Abs_arr_inverse FC_arr_char One_def UNIV_I Zero_def comp_def
              mkArr_def
        by auto
    qed

    lemma in_hom_char:
    shows "\<guillemotleft>f : a \<rightarrow> b\<guillemotright> \<longleftrightarrow> (a = Zero \<and> b = Zero \<and> f = Zero) \<or>
                            (a = One \<and> b = One \<and> f = One) \<or>
                            (a = Zero \<and> b = One \<and> f \<in> mkArr ` Arr)"
    proof -
      have "f = Zero \<Longrightarrow> ?thesis"
        using arr_char [of f]
        by (metis ide_char ide_in_hom image_iff in_homE not_ide_mkArr)
      moreover have "f = One \<Longrightarrow> ?thesis"
        using arr_char [of f]
        by (metis ide_char ide_in_hom image_iff in_homE not_ide_mkArr)
      moreover have "f \<in> mkArr ` Arr \<Longrightarrow> ?thesis"
      proof -
        assume f: "f \<in> mkArr ` Arr"
        have 1: "arr f" using f by (simp add: arr_char)
        moreover have "dom f = Zero \<and> cod f = One"
          using f 1 AC.dom_char AC.cod_char AC.rep_abs comp_def mkArr_def Zero_def One_def
          by auto
        ultimately have "in_hom f Zero One" by auto
        thus "in_hom f a b \<longleftrightarrow> (a = Zero \<and> b = Zero \<and> f = Zero \<or>
                                           a = One \<and> b = One \<and> f = One \<or>
                                           a = Zero \<and> b = One \<and> f \<in> mkArr ` Arr)"
          by (metis f in_homE ide_char ide_in_hom)
      qed
      ultimately show ?thesis
        using arr_char [of f] by fast
    qed

    lemma Zero_not_eq_One [simp]:
    shows "Zero \<noteq> One"
      using Zero_def One_def
      by (metis Abs_arr_inverse FC.not_arr_null FC.null_char FC_arr_char UNIV_I FC.Dom_mkArr)

    lemma Zero_not_in_mkArr_Arr [simp]:
    shows "Zero \<notin> mkArr ` Arr"
      by (metis ide_char imageE not_ide_mkArr)

    lemma One_not_in_mkArr_Arr [simp]:
    shows "One \<notin> mkArr ` Arr"
      by (metis ide_char imageE not_ide_mkArr)

    lemma dom_char:
    shows "dom f = (if ide f then f else if arr f then Zero else null)"
      using ide_char arr_char in_hom_char
      by (metis has_domain_iff_arr in_homE dom_def)

    lemma dom_simp [simp]:
    shows "dom One = One"
    and "\<lbrakk>arr f; f \<noteq> One\<rbrakk> \<Longrightarrow> dom f = Zero"
      using dom_char ide_char by auto

    lemma cod_char:
    shows "cod f = (if ide f then f else if arr f then One else null)"
      using ide_char arr_char in_hom_char
      by (metis has_codomain_iff_arr in_homE cod_def)

    lemma cod_simp [simp]:
    shows "cod Zero = Zero"
    and "\<lbrakk>arr f; f \<noteq> Zero\<rbrakk> \<Longrightarrow> cod f = One"
      using cod_char ide_char by auto

    lemma seq_char:
    shows "seq g f \<longleftrightarrow> arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
    proof
      assume gf: "seq g f"
      hence 1: "arr f \<and> arr g \<and> cod f = dom g" by auto
      have f: "arr f \<and> (f = Zero \<or> f = One \<or> f \<in> mkArr ` Arr)" using gf arr_char by auto
      have g: "arr g \<and> (g = Zero \<or> g = One \<or> g \<in> mkArr ` Arr)" using gf arr_char by auto
      have "f = Zero \<Longrightarrow> g \<noteq> One"
        using f g 1 by force
      moreover have "f = One \<Longrightarrow> g = One"
        using f g 1 by (metis Zero_not_eq_One cod_simp(2) dom_simp(2))
      moreover have "f \<in> mkArr ` Arr \<Longrightarrow> f \<noteq> Zero \<and> g = One"
        using f 1 arr_char [of f]
        by (metis Zero_not_eq_One Zero_not_in_mkArr_Arr cod_simp(2) dom_simp(2))
      ultimately show "arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
        using f g arr_char [of f] arr_char [of g] by blast
      next
      assume gf: "arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
      thus "seq g f" using in_hom_char by auto
    qed

    lemma comp_char:
    shows "g \<cdot> f = (if seq g f then
                      if f = Zero then g else if g = One then f else null
                    else null)"
    proof -
      have "seq g f \<Longrightarrow> f = Zero \<Longrightarrow> g \<cdot> f = g"
        using comp_def seq_char [of g f] AC.comp_char [of g f] Zero_def cod_simp(1)
        by (metis comp_arr_dom dom_simp(2))
      moreover have "seq g f \<Longrightarrow> g = One \<Longrightarrow> g \<cdot> f = f"
        using comp_def seq_char [of g f] AC.comp_char [of g f] One_def dom_simp(1)
        by (metis comp_cod_arr cod_simp(2))
      moreover have "seq g f \<Longrightarrow> f \<noteq> Zero \<Longrightarrow> g \<noteq> One \<Longrightarrow> g \<cdot> f = null"
        using seq_char by blast
      moreover have "\<not>seq g f \<Longrightarrow> g \<cdot> f = null"
        using comp_def AC.comp_char ext by fastforce
      ultimately show ?thesis by argo
    qed

    lemma comp_simp [simp]:
    assumes "seq g f"
    shows "f = Zero \<Longrightarrow> g \<cdot> f = g"
    and "g = One \<Longrightarrow> g \<cdot> f = f"
    proof -
      show "f = Zero \<Longrightarrow> g \<cdot> f = g"
        using assms seq_char comp_char by metis
      show "g = One \<Longrightarrow> g \<cdot> f = f"
        using assms seq_char comp_char by metis
    qed

    lemma arr_mkArr:
    assumes "x \<in> Arr"
    shows "arr (mkArr x)"
      using assms mkArr_def arr_char image_eqI by blast

    lemma toArr_in_Arr:
    assumes "arr f" and "\<not>ide f"
    shows "toArr f \<in> Arr"
    proof -
      have "\<And>a. a \<in> Arr \<Longrightarrow> FC.Path (Rep_arr (mkArr a)) = [a]"
        by (metis AC.domain_closed Abs_arr_inverse FC.Path_mkArr FC.arr_char FC.arr_single
                  mkArr_def)
      hence "hd (FC.Path (Rep_arr f)) \<in> Arr"
        using arr_char assms(1) assms(2) ide_char by auto
      thus ?thesis
        by (simp add: toArr_def)
    qed

    lemma toArr_mkArr [simp]:
    assumes "x \<in> Arr"
    shows "toArr (mkArr x) = x"
      using assms mkArr_def toArr_def
      by (metis Abs_arr_inverse FC.G.path_single_Arr UNIV_I FC.Path_mkArr FC.mkArr_not_Null
                list.sel(1))

    lemma mkArr_toArr [simp]:
    assumes "arr f" and "\<not>ide f"
    shows "mkArr (toArr f) = f"
      using assms arr_char ide_char imageE toArr_mkArr by auto

  end

  sublocale quiver \<subseteq> category comp
    using is_category by auto

  section "Parallel Pairs"

  text\<open>
    A parallel pair is a quiver with two non-identity arrows.
    It is important in the definition of equalizers.
\<close>

  locale parallel_pair =
    Q: quiver "{False, True} :: bool set"
  begin

    typedef arr = "UNIV :: bool quiver.arr set" ..

    interpretation AC: abstracted_category Q.comp Abs_arr Rep_arr UNIV
      using Rep_arr_inverse Abs_arr_inverse apply unfold_locales by auto

    definition comp     (infixr "\<cdot>" 55)
    where "comp \<equiv> AC.comp"

    lemma is_category:
    shows "category comp"
    proof -
      have "category AC.comp" ..
      thus "category comp" using comp_def by metis
    qed

    interpretation category comp
      using is_category by auto

    notation in_hom ("\<guillemotleft>_ : _ \<rightarrow> _\<guillemotright>")

    definition Zero
    where "Zero \<equiv> Abs_arr Q.Zero"

    definition One
    where "One \<equiv> Abs_arr Q.One"

    definition j0
    where "j0 \<equiv> Abs_arr (Q.mkArr False)"

    definition j1
    where "j1 \<equiv> Abs_arr (Q.mkArr True)"

    lemma arr_char:
    shows "arr f \<longleftrightarrow> f = Zero \<or> f = One \<or> f = j0 \<or> f = j1"
    proof -
      have 1: "Rep_arr f = Q.Zero \<or> Rep_arr f = Q.One \<or> Rep_arr f \<in> Q.mkArr ` {False, True}
                 \<longrightarrow> arr f"
        by (simp add: AC.arr_char Q.arr_char comp_def)
      have 2: "\<forall>a. a \<in> UNIV \<longrightarrow> Rep_arr (Abs_arr a) = a"
        by (simp add: Abs_arr_inverse)
      hence 3: "Rep_arr (Abs_arr (Q.mkArr True)) = Q.mkArr True"
        by blast
      hence 4: "f = j1 \<longrightarrow> arr f"
        using 1 j1_def by auto
      have "f = j0 \<or> f = Zero \<or> f = One \<longrightarrow> arr f"
        using 1 2 Zero_def One_def by (metis (no_types) UNIV_I insertI1 j0_def rev_image_eqI)
      thus ?thesis
        using 2 3 4
        by (metis (full_types) AC.arr_char One_def Q.ide_char Q.mkArr_toArr Rep_arr_inject
            UNIV_I Zero_def j0_def j1_def comp_def)
    qed

    lemma dom_char:
    shows "dom f = (if f = j0 \<or> f = j1 then Zero else if arr f then f else null)"
      using comp_def
      by (metis (full_types) AC.arr_char AC.dom_char Abs_arr_inverse One_def Q.dom_char
          Q.ide_char Q.not_ide_mkArr UNIV_I Zero_def arr_char j0_def j1_def)

    lemma cod_char:
    shows "cod f = (if f = j0 \<or> f = j1 then One else if arr f then f else null)"
      using comp_def
      by (metis (full_types) AC.arr_char AC.cod_char Abs_arr_inverse One_def Q.cod_char
          Q.ide_char Q.not_ide_mkArr UNIV_I Zero_def arr_char j0_def j1_def)

    lemma ide_char:
    shows "ide a \<longleftrightarrow> a = Zero \<or> a = One"
      using ide_in_hom arr_char
      by (metis (no_types, lifting) AC.ide_char Q.ide_char UNIV_I Zero_def in_homE j0_def j1_def
          comp_def Abs_arr_inverse One_def)

    lemma Zero_not_eq_One [simp]:
    shows "Zero \<noteq> One"
      using Zero_def One_def Q.Zero_def Q.One_def
      by (metis AC.rep_abs Q.Zero_not_eq_One UNIV_I)

    lemma j0_not_eq_j1 [simp]:
    shows "j0 \<noteq> j1"
      by (metis (full_types) Abs_arr_inverse Q.toArr_mkArr UNIV_I UNIV_bool j0_def j1_def)

    lemma Zero_not_eq_j0 [simp]:
    shows "Zero \<noteq> j0"
      using Zero_def j0_def by (metis Abs_arr_inverse Q.ide_char Q.not_ide_mkArr UNIV_I)

    lemma Zero_not_eq_j1 [simp]:
    shows "Zero \<noteq> j1"
      using Zero_def j1_def by (metis Abs_arr_inverse Q.ide_char Q.not_ide_mkArr UNIV_I)

    lemma One_not_eq_j0 [simp]:
    shows "One \<noteq> j0"
      using One_def j0_def by (metis Abs_arr_inverse Q.ide_char Q.not_ide_mkArr UNIV_I)

    lemma One_not_eq_j1 [simp]:
    shows "One \<noteq> j1"
      using One_def j1_def by (metis Abs_arr_inverse Q.ide_char Q.not_ide_mkArr UNIV_I)

    lemma dom_simp [simp]:
    shows "dom Zero = Zero"
    and "dom One = One"
    and "dom j0 = Zero"
    and "dom j1 = Zero"
      using dom_char arr_char by auto

    lemma cod_simp [simp]:
    shows "cod Zero = Zero"
    and "cod One = One"
    and "cod j0 = One"
    and "cod j1 = One"
      using cod_char arr_char by auto

    lemma seq_char:
    shows "seq g f \<longleftrightarrow> arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
    proof
      assume gf: "seq g f"
      have f: "arr f \<and> (f = Zero \<or> f = One \<or> f = j0 \<or> f = j1)" using gf arr_char by blast
      have g: "arr g \<and> (g = Zero \<or> g = One \<or> g = j0 \<or> g = j1)" using gf arr_char by blast
      have "f = Zero \<Longrightarrow> g \<noteq> One"
        using f g gf
        by (metis Zero_not_eq_One seqE cod_simp(1) dom_simp(2))
      moreover have "f \<noteq> Zero \<Longrightarrow> g = One"
        using f g gf by auto
      ultimately show "arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
        using f g by blast
      next
      assume gf: "arr g \<and> arr f \<and> ((f = Zero \<and> g \<noteq> One) \<or> (f \<noteq> Zero \<and> g = One))"
      have "f = Zero \<Longrightarrow> seq g f" using gf arr_char [of g] by auto
      moreover have "g = One \<Longrightarrow> seq g f" using gf arr_char [of f] by auto
      ultimately show "seq g f" using gf by blast
    qed

    lemma comp_char:
    shows "g \<cdot> f = (if seq g f then
                      if f = Zero then g else if g = One then f else null
                    else null)"
    proof -
      have "\<not>seq g f \<Longrightarrow> g \<cdot> f = null"
        using comp_def AC.comp_char Q.comp_char seq_char ext by blast
      moreover have "seq g f \<Longrightarrow> f = Zero \<Longrightarrow> g \<cdot> f = g"
        using comp_arr_dom by auto
      moreover have "seq g f \<Longrightarrow> g = One \<Longrightarrow> g \<cdot> f = f"
        using comp_cod_arr by auto
      ultimately show ?thesis
        by (metis seqE seq_char)
    qed

    lemma comp_simp [simp]:
    assumes "seq g f"
    shows "f = Zero \<Longrightarrow> g \<cdot> f = g"
    and "g = One \<Longrightarrow> g \<cdot> f = f"
    proof -
      show "f = Zero \<Longrightarrow> g \<cdot> f = g"
        using assms comp_char by metis
      show "g = One \<Longrightarrow> g \<cdot> f = f"
        using assms comp_char seq_char by metis
    qed

  end

  sublocale parallel_pair \<subseteq> category comp
    using is_category by auto

end
